// Copyright 2014 AKUALAB INC. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// optgen generates functional options. Intended to be
// used with go generate; see the invocation in example/hello.go.

// To learn about functional options, see:
// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis
// http://commandcenter.blogspot.com.au/2014/01/self-referential-functions-and-design.html

// This code is based on encgen.go from the encoding/gob package and the stringer cmd.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"strings"

	_ "golang.org/x/tools/go/gcimporter"
	"golang.org/x/tools/go/types"
)

var typeNameArg = flag.String("type", "", "type name of the options struct; must be set")
var fieldNames = flag.String("fields", "", "comma-separated list of struct fields to generate options")
var output = flag.String("output", "", "output file name; default srcdir/<type>_gen_opt.go")

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\toptioner [flags] -type T -fields F\n")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://github.com/akualab/optioner\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("optioner: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeNameArg) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	if len(*fieldNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	// Parse the package once.
	var (
		g Generator
	)

	g.typeName = *typeNameArg
	g.options = map[string]string{}
	for _, v := range strings.Split(*fieldNames, ",") {
		g.options[v] = ""
	}

	// fn := "example/example.go"
	// source, e := ioutil.ReadFile(fn)
	// if e != nil {
	// 	panic(e)
	// }

	// g.src = source
	// fset := token.NewFileSet()
	// //	f, err := parser.ParseFile(fset, "", src, 0)
	// f, err := parser.ParseFile(fset, "", source, 0)

	// if err != nil {
	// 	panic(err)
	// }

	g.parsePackage()

	// Print the header and package clause.
	g.Printf("// generated by optioner %s; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	//	g.Printf("package %s", g.pkg.name)
	g.Printf("\n")
	g.Printf("import \"fmt\"\n") // Used by all methods.

	// Run generate for target type.
	//	g.generate(typeName)

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_gen_opt.go", g.typeName)
		outputName = strings.ToLower(baseName)
	}
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *Generator) parsePackage() {

	pkg, err := build.Default.ImportDir(".", 0)
	if err != nil {
		log.Fatalf("cannot process directory: %s", err)
	}

	for _, f := range pkg.GoFiles {
		g.parseFields(f)
	}
}

func (g *Generator) parseFields(fn string) {

	log.Println("parse file: ", fn)
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fn, nil, 0)

	if err != nil {
		log.Fatal(err)
	}

	for k, v := range f.Decls {
		fmt.Println("xxxx Decl: ", k, v)
		if genDecl, ok := v.(*ast.GenDecl); ok {
			fmt.Println("xxxx genDecl: ", genDecl)
			fmt.Println("xxxx genDecl token is type?: ", genDecl.Tok == token.TYPE)
			if genDecl.Tok != token.TYPE {
				continue
			}
			for i, s := range genDecl.Specs {
				fmt.Println("xxxx spec: ", i, s)
				if typeSpec, ok := s.(*ast.TypeSpec); ok {
					fmt.Println("xxxx type spec: ", typeSpec)
					if typeSpec.Name.String() != g.typeName {
						continue
					}
					fmt.Println("xxxx type name: ", typeSpec.Name)
					if structDecl, ok := typeSpec.Type.(*ast.StructType); ok {
						fmt.Println("xxxx struct decl: ", structDecl)
						fields := structDecl.Fields.List
						for _, field := range fields {
							fmt.Println("xxxx field: ", field)
							id := field.Names[0]
							fmt.Println("xxxx field name: ", id.Name)
							fmt.Println("xxxx field obj: ", id.Obj.Kind)

							// check if field is in options
							// otherwise get next field.
							if _, ok := g.options[id.Name]; !ok {
								continue
							}

							tid := field.Type
							fmt.Println("xxxx field type: ", tid)
							// if len(field.Names) > 0 {
							// 	fmt.Println("xxxx field name: ", field.Names[0])
							// }

							// tag := ""
							// if field.Tag != nil {
							// 	fmt.Println("xxxx field tag: ", field.Tag)
							// 	tag = field.Tag.Value
							// }

							typeExpr := field.Type
							//							start := typeExpr.Pos() - 1
							//							end := typeExpr.End() - 1

							//							fmt.Println(">>>>>>>>>>", types.ExprString(typeExpr))

							// grab it in source
							//							typ := string(g.src[start:end])
							typ := types.ExprString(typeExpr)

							g.options[id.Name] = typ
							fmt.Println(id.Name, typ)
						}
						fmt.Println("xxxx DONE! ")

						// check that we found all fields for options
						for n, v := range g.options {
							if len(v) == 0 {
								log.Fatalf("there is no field [%s] in struct, cannot generate option", n)
							}
						}
						return
					} else {
						log.Fatal("target type is not a struct")
					}
				}
			}
		}
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf     bytes.Buffer      // Accumulated output.
	pkg     *Package          // Package we are scanning.
	options map[string]string // maps option name to type
	//	src     []byte
	typeName string
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// generate produces the String method for the named type.
func (g *Generator) generate(typeName string) {

	//	fields := make([]Field, 0, 100)
	// for _, file := range g.pkg.files {
	// 	// Set the state for this run of the walker.
	// 	file.typeName = typeName
	// 	file.values = nil
	// 	if file.file != nil {
	// 		ast.Inspect(file.file, file.genDecl)
	// 		values = append(values, file.values...)
	// 	}
	// }

	// case *ast.StructType:
	// 	for _, f := range v.Fields.List {
	// 		for _, id := range f.Names {
	// 			check(id, "struct field")
	// 		}
	// 	}
	// }

	// DEBUG
	fmt.Println("DEBUG: pkg name: ", g.pkg.name)
	fmt.Println("DEBUG: pkg path: ", g.pkg.typesPkg.Path())
	for k, f := range g.pkg.files {
		fmt.Println("DEBUG: file ", k, "struct type: ", f.typeName)
	}

	// // ExampleOpt type is used to pass options to Example.
	// type ExampleOpt func(*Example)
	g.Printf("\n// Option type is used to pass options to %s.\n", typeName)
	g.Printf("type Option func(*%s)\n", typeName)
	g.Printf("\n")

	// Get fields for struct.

	//	values := make([]Value, 0, 100)
	for _, file := range g.pkg.files {
		// Set the state for this run of the walker.
		file.typeName = typeName
		//		file.values = nil
		if file.file != nil {
			//			ast.Inspect(file.file, file.genDecl)
			//			values = append(values, file.values...)
		}
	}

	//	if len(values) == 0 {
	//		log.Fatalf("no values defined for type %s", typeName)
	//	}
	//	runs := splitIntoRuns(values)
	// The decision of which pattern to use depends on the number of
	// runs in the numbers. If there's only one, it's easy. For more than
	// one, there's a tradeoff between complexity and size of the data
	// and code vs. the simplicity of a map. A map takes more space,
	// but so does the code. The decision here (crossover at 10) is
	// arbitrary, but considers that for large numbers of runs the cost
	// of the linear scan in the switch might become important, and
	// rather than use yet another algorithm such as binary search,
	// we punt and use a map. In any case, the likelihood of a map
	// being necessary for any realistic example other than bitmasks
	// is very low. And bitmasks probably deserve their own analysis,
	// to be done some other day.
	// switch {
	// case len(runs) == 1:
	// 	g.buildOneRun(runs, typeName)
	// case len(runs) <= 10:
	// 	g.buildMultipleRuns(runs, typeName)
	// default:
	// 	g.buildMap(runs, typeName)
	// }
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

const header = `
// Copyright 2014 AKUALAB INC. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gob

import (
	"reflect"
)

`

const arrayHelper = `
func enc%[2]sArray(state *encoderState, v reflect.Value) bool {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return false
	}
	return enc%[2]sSlice(state, v.Slice(0, v.Len()))
}
`

const sliceHelper = `
func enc%[2]sSlice(state *encoderState, v reflect.Value) bool {
	slice, ok := v.Interface().([]%[1]s)
	if !ok {
		// It is kind %[1]s but not type %[1]s. TODO: We can handle this unsafely.
		return false
	}
	for _, x := range slice {
		if x != %[3]s || state.sendZero {
			%[4]s
		}
	}
	return true
}
`
